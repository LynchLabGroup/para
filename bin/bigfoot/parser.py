#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Contains SeqParser class to handle BigFoot's outputs and parse them using appropriate thresholds.
"""

# IMPORTS ###
from time import gmtime, strftime, sleep

from weight import WeightSeq


class SeqParser(object):
	"""
	Object that takes in parameter BigFoot's alignement file and phylogenetic prediction file. It can parse file to extract motifs.
	"""

	def __init__(self, seqfile, predfile):
		"""
		seqfile - BigFoot's StatAlign ouput file '.mpd'
		predfile - BigFoot's '.pred' file of phylogenetic prediction
		"""

		self._seqfile = seqfile
		self._predfile = predfile
		self._parse = None  # to stock the parsed sequences
		self._motifs = None

	def __str__(self):

		s = "Sequence File: {}\nPrediction File: {}".format(self._seqfile, self._predfile)

		return s

	def __repr__(self):
		return self.__str__()

	def parse(self):
		"""
		Returns a list of WeightSeq extracted from the sequence file
		"""

		if self._parse is None:

			seqs = []  # list of Weighted Sequences generated by parsing file

			with open(self._seqfile,"r") as f:
				for i, l in enumerate(f.readlines()):
					try:
						float(l)  # try if line is numbers only
					except ValueError:
						seqs.append(WeightSeq(l))

			self._parse = seqs

			return seqs
		else:
			return "Sequence file was already parsed"

	def motifs(self, thre, size, align):
		"""
		Returns a dictionary of sequences motifs, using the prediction threshold thre and bigger than given size
		"""

		if self._parse is None:
			print "No previous parsing"
			print "Parsing file..."
			seqs = self.parse()
			self._parse = seqs
			print "Done"
		else:
			seqs = self._parse

		seqs[0].weight(self._predfile, self._seqfile)  # weight first sequence
		sleep(1)
		known = seqs[0].motifs(thre, size, align)   # extract motifs with given threshold from first sequence

		mot = {}  # known motifs dictionary

		for i, k in enumerate(known):

			name = "motif"+str(i+1)  # enumerate motifs

			mot[name] = {}
			mot[name]["size"] = k[2] - k[1] + 1  # compute the size of the motif
			
			mot[name]["start"] = k[5] + 1  # start position of motif real position
			mot[name]["stop"] = k[5]+mot[name]["size"]  # end position of motif
			mot[name]["score"] = k[3]  # average score real position
		
			mot[name]["align"] = k[4]  # average alignment score of sequence

			for j, s in enumerate(seqs):
				mot[name][s.name()] = {} 
				mot[name][s.name()]["seq"] = s[k[1]:k[2]]  # extract motif from each sequence
				mot[name][s.name()]["start"] = s.get_real_pos(k[1])
				if j == 0:
					mot[name]["start"] = mot[name][s.name()]["start"]  # start position of motif real position

		mot["threshold"] = thre  # general threshold used
		mot["size"] = size  # size used to detect motifs
		mot["align"] = align  # used alignment score
		self._motifs = mot

		return mot

	def write(self, output):
		"""
		Write the output file of all the found motifs. Compute the motifs search first.
		"""

		keys = self._motifs.keys()
		keys.sort()
		
		thre = self._motifs['threshold']  # threshold used for motif detection
		size = self._motifs["size"]  # size used to detect motifs
		align = self._motifs["align"]  # alignment score used to detect motifs

		with open(output, "w") as o:

			# Print the precise time of the computation and print the whole results file
			print >> o, "Launched:{} GMT Threshold used: {} AlignThreshold: {} Size(over): {}\n".format(strftime("%a, %d %b %Y %H:%M:%S", gmtime()), thre, align, size)
			for k in keys:
				if k != "threshold" and k != "size" and k != "align":
					smk = self._motifs[k]  # motif number X, SMK stands for Self._Motifs[K]

					# print the general information for this particular motif
					print >> o, "\n{} Start: {} Stop: {} AvgPhylogeneticScore: {} AvgAlignScore: {} Size: {}\n".format(k, smk["start"],smk["stop"],  smk["score"], smk["align"], smk["size"])

					sub = smk.keys()
					sub.sort()  # to have always the same order of sequences
					# print sequences
					for s in sub:
						if s != "start" and s != "stop" and s != "score" and s != "size" and s != "align":
							print >> o, "{0:20}\t{1:20}\t{2}".format(s, smk[s]["start"], smk[s]["seq"].upper())	