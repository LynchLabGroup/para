#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Contains SeqParser class to handle BigFoot's outputs and parse them using
appropriate thresholds.
"""

# IMPORTS ###
from time import gmtime, strftime, sleep

from weight import WeightSeq


class SeqParser(object):
    """
    Object that takes in parameter BigFoot's alignement file and phylogenetic
    prediction file. It can parse file to extract motifs.
    """

    def __init__(self, seqfile, predfile):
        """
        seqfile - BigFoot's StatAlign ouput file '.mpd'
        predfile - BigFoot's '.pred' file of phylogenetic prediction
        """
        assert seqfile.endswith(".mpd"), predfile.endswith(".pred")

        self._seqfile = seqfile
        self._predfile = predfile
        self._parse = None  # to stock the parsed sequences
        self._motifs = None

    def __str__(self):

        s = "Sequence File: {}\nPrediction File: {}".format(self._seqfile,
                                                            self._predfile)

        return s

    def __repr__(self):
        return self.__str__()

    def parse(self):
        """
        Returns a list of WeightSeq extracted from the sequence file
        """

        if self._parse is None:

            seqs = []  # list of Weighted Sequences generated by parsing file

            with open(self._seqfile, "r") as f:
                for i, l in enumerate(f.readlines()):
                    try:
                        float(l)  # try if line is numbers only
                    except ValueError:
                        seqs.append(WeightSeq(l))

            self._parse = seqs

            return seqs
        else:
            return "Sequence file was already parsed"

    def motifs(self, thre, align):
        """
        Returns a dictionary of sequences motifs, using the prediction
        threshold thre.
        """

        if self._parse is None:
            print "No previous parsing"
            print "Parsing file..."
            seqs = self.parse()
            self._parse = seqs
            print "Done"
        else:
            seqs = self._parse

        seqs[0].weight(self._seqfile, self._predfile)  # weight first sequence
        sleep(1)
        known = seqs[0].motifs(thre, align)   # extract motifs from first seq

        mot = {}  # known motifs dictionary

        for i, k in enumerate(known):

            name = "motif"+str(i+1)  # enumerate motifs

            mot[name] = {}
            mot[name]["size"] = k[2] - k[1] + 1  # size of the motif

            # start position of motif real position
            mot[name]["start"] = k[5] + 1
            mot[name]["stop"] = k[5]+mot[name]["size"]  # end position of motif
            mot[name]["score"] = k[3]  # average score real position

            mot[name]["align"] = k[4]  # average alignment score of sequence

            for j, s in enumerate(seqs):
                mot[name][s.name()] = {}
                # extract motif from each sequence
                mot[name][s.name()]["seq"] = s[k[1]:k[2]]
                mot[name][s.name()]["start"] = s.get_real_pos(k[1])
                if j == 0:
                    # real position
                    mot[name]["start"] = mot[name][s.name()]["start"]

        mot["threshold"] = thre  # general threshold used
        mot["align"] = align  # used alignment score
        self._motifs = mot

        return mot

    def write(self, output):
        """
        Write the output file of all the found motifs. Compute the motifs search first.
        """

        keys = self._motifs.keys()
        keys.sort()

        thre = self._motifs['threshold']  # threshold used for motif detection
        align = self._motifs["align"]  # alignment score used to detect motifs

        with open(output, "w") as o:

            # Precise time of the computation and print the whole results file
            print >> o, "Launched:{} GMT Threshold used: {} AlignThreshold: {}\n" \
                .format(strftime("%a, %d %b %Y %H:%M:%S", gmtime()), thre, align)
            for k in keys:
                if k != "threshold" and k != "size" and k != "align":
                    smk = self._motifs[k]  # motif number X, SMK stands for
                    # Self._Motifs[K]

                    # print the general information for this particular motif
                    print >> o, "\n{} Start: {} Stop: {}".format(k, smk["start"], smk["stop"])\
                     + "AvgPhylogeneticScore: {} AvgAlignScore: {} Size: {}\n"\
                     .format(smk["score"], smk["align"], smk["size"])

                    sub = smk.keys()
                    sub.sort()  # to have always the same order of sequences
                    # print sequences
                    for s in sub:
                        if s != "start" and s != "stop" and s != "score" \
                           and s != "align" and s != "size":
                            print >> o, "{0:20}\t{1:20}\t{2}".format(s, smk[s]["start"], smk[s]["seq"].upper()) 