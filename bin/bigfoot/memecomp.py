#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Memecomp.py contains function to parse motifs file,
as well as comparison functions, to compare found motifs.
"""

### IMPORTS ###
import itertools as it
import time
from Bio import motifs
from Bio.Alphabet import Gapped
from Bio.Alphabet.IUPAC import ExtendedIUPACDNA
### CLASSES ###
class MotifFile(object):
	"""
	Parsed motif file generated by custom script. Convert all motifs into WeightedMotif objects, extensions of the Motif object in Bio.motifs.meme (Biopython). That way, motifs can be compare easily.
	"""

	def __init__(self,filename):

		with open(filename,"r") as f:
			i = 0
			records = []
			for key, group in it.groupby(f, lambda line: line.startswith("\n")):
				if not key:
					block = list(group)
					if i == 0:
						s = block[0] # line string
						s = s.rstrip("\n").lstrip("Launched:")
						s = s.split(" ")
						date = " ".join(s[0:5])
						pred_thre = float(s[-5])
						ali_thre = float(s[-3])
						size_thre = float(s[-1])
					elif i % 2 == 1:
						mot = []
						mot.append(block)
					elif i % 2 == 0:
						mot.append(block)
						m = read_motif_seq(mot)
						records.append(m)

					i += 1

		self._filename = filename
		self._date = time.strptime(date, "%a, %d %b %Y %H:%M:%S")
		self._pred_thre = pred_thre
		self._ali_thre = ali_thre
		self._size_thre = size_thre
		self._motifs = records

	def __str__(self):
		"""Method called when 'print object' is used. """

		s = "File: {} Date: {}\nThresholds: {} (Pred) {} (Align) {} (Size)\nMotifs found: {}".format(self.filename(), self.date(), self.pred(), self.ali(), self.size(), len(self.motifs()))
		return s

	def __repr__(self):

		return self.__str__()

	def __getitem__(self, index):
		"""Return the motif of the given index."""

		return self._motifs[index]
	
	def __iter__(self):
		"""Iterates over motifs in MotifFile."""

		return self._motifs.__iter__()

	def pred(self):
		"""Return the prediction score (phylogenetic score) threshold used in the file."""
		return self._pred_thre
	
	def ali(self):
		"""Return the average alignment score threshold used in BigFoot's analysis."""
		return self._ali_thre
	
	def size(self):
		"""Return the size threshold used in the anaysis."""
		return self._size_thre
	
	def date(self):
		"""Return the date the analysis was done."""
		return time.strftime("%a, %d %b %Y %H:%M:%S", self._date)
	
	def filename(self):
		"""Return the name of parsed BigFoot's output file."""
		return self._filename

	def motifs(self):
		"""Return a list of found motifs."""
		return self._motifs

class WeightedMotif(motifs.meme.Motif):
	"""
	Extension of Bio.motifs.meme Motif class, adding two attributes:
		- self.pred: average prediction (phylogenetic) score of the given motif
		- self.ali: average alignment score of the given motif
	"""
	def __init__(self, alphabet, instances, phylo_score, align_score):
		motifs.meme.Motif.__init__(self, alphabet, instances)
		self.pred = phylo_score
		self.ali = align_score

def read_motif_seq(block):
	"""
	From the block of lines used in MotifFile, return a Motif object
	"""
	gapped = Gapped(ExtendedIUPACDNA(), '-')
	instances = []
	head = block[0][0]
	head = head.rstrip("\n").split(" ")
	motif_name = head[0]
	motif_length = head[-1]

	for l in block[1]:
		l = l.rstrip("\n").split("\t")
		instance = motifs.meme.Instance(l[-1], gapped)
		
		instance.motif_name = motif_name
		instance.sequence_name = l[0].translate(None, " ")
		instance.start = int(l[1].translate(None," "))
		instance.length = int(motif_length)

		instances.append(instance)

	inst = motifs.Instances(instances, gapped)

	motif = WeightedMotif(gapped, inst, float(head[-5]), float(head[-3]))
	motif.length = motif_length
	motif.name = motif_name

	return motif

def load_meme(filename):
	"""
	Return a parsed MEME output file using Biopython.
	"""
	gapped = Gapped(ExtendedIUPACDNA(), '-')

	with open(filename, "r") as f:
		records = motifs.parse(f, "meme")

	records = convert(records, gapped)
	return records

def convert(motifs_list, alphabet):
	"""
	Returns a new list of motifs converting using given alphabet.
	"""

	new_list = []
	for m in motifs_list:
		tot_inst = []
		
		# Recreate instances using given alphabet
		for i in m.instances:
			inst = motifs.meme.Instance(i.tostring(), alphabet)
			inst.motif_name = i.motif_name
			inst.sequence_name = i.sequence_name
			inst.start = i.start
			inst.length = i.length

			tot_inst.append(inst)
		
		# Converting instances and motis
		instances = motifs.Instances(tot_inst, alphabet)
		mot = motifs.meme.Motif(alphabet, instances)
		new_list.append(mot)

	return new_list

def compare_motifs(bigfoot_motifs, meme_motifs, threshold=None):
	"""
	Compare motifs found in bigfoot and meme outputs, using an overlapping threshold index (float)
	"""
	if threshold == None:
		threshold = 0.9

	# Look at all motifs of bigfoot file
	for bf_mot in bigfoot_motifs.motifs():
		# Compare only first instance of each bf_mot
		inst = bf_mot.instances[0]
		
		start = inst.start
		end = start + inst.length - 1
		bf_range = (start, end)

		seq_name = inst.sequence_name

		# Compare the first instance of one motifs to all other motifs in MEME
		for m_mot in meme_motifs:
			for m in m_mot.instances:
				if m.sequence_name == seq_name:
					# We found the instance from the same sequence \o/
					break
			m_start = m.start
			m_end = start + m.length - 1
			m_range = (start, end)

			index, stat = overlap(bf_range, m_range)

			if index and stat >threshold:
				print "Bigfoot's: {} MEME:{} Stat: {}".format(inst.motif_name, m_mot.name, stat)

def overlap(r1, r2):
	"""
	Returns if the two ranges are overlapping. Notes, range should be given in order

	Examples:
	>>> overlap((2,3), (5,10))
	(False, 0.0)
	>>> overlap((2,3), (1,10))
	(True, 0.2)
	>>> overlap((5,15), (3,8))
	(True, 0.36363636363636365)
	>>> overlap((3,7), (5,9))
	(True, 0.6)
	"""
	stat = 0.0

	index = (r2[0] <= r1[0] <= r2[1]) or (r1[0] <= r2[0] <= r1[1])

	if index:

		r1_len = r1[1] - r1[0] + 1
		r2_len = r2[1] - r2[0] + 1
		mini = min(r1_len, r2_len)

		# If range is included into the other
		if (r2[0] <= r1[0] <= r2[1]) and (r2[0] <= r1[1] <= r2[1]):
			over_r = r1_len
		elif (r1[0] <= r2[0] <= r1[1]) and (r1[0] <= r2[1] <= r1[1]):
			over_r = r2_len
		# If ranges are overlapping partially
		elif (r2[0] <= r1[0] <= r2[1]):
			over_r = r2[1] - r1[0] + 1
		elif (r1[0] <= r2[0] <= r1[1]):
			over_r = r1[1] - r2[0] + 1

		stat = float(over_r)/mini

	return index, stat
