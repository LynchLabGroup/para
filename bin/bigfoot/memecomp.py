#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Memecomp.py contains function to parse motifs file,
as well as comparison functions, to compare found motifs.
"""

# ## DEBUG ###
# import pdb

# ## IMPORTS ###
import itertools as it
import time
from Bio import motifs
from Bio.motifs import meme

from Bio.Alphabet import Gapped
from Bio.Alphabet.IUPAC import ExtendedIUPACDNA
import argparse

# ## CLASSES ###


class MotifFile(object):
    """
    Parsed motif file generated by custom script. Convert all motifs into \
    WeightedMotif objects, extensions of the Motif object in Bio.motifs.meme \
    (Biopython). That way, motifs can be compared easily.
    """

    def __init__(self, filename):

        with open(filename, "r") as f:
            i = 0
            records = []
            for key, group in it.groupby(f, lambda line: line.startswith("\n")):
                if not key:
                    block = list(group)
                    if i == 0:
                        s = block[0]  # line string
                        s = s.rstrip("\n").lstrip("Launched:")
                        s = s.split(" ")
                        date = " ".join(s[0:5])
                        pred_thre = float(s[-3])
                        ali_thre = float(s[-1])
                    elif i % 2 == 1:
                        mot = []
                        mot.append(block)
                    elif i % 2 == 0:
                        mot.append(block)
                        m = _read_motif_seq(mot)
                        records.append(m)

                    i += 1

        self._filename = filename
        self._date = time.strptime(date, "%a, %d %b %Y %H:%M:%S")
        self._pred_thre = pred_thre
        self._ali_thre = ali_thre
        self.motifs = records

    def __str__(self):
        """Method called when 'print object' is used. """

        s = "File: {} Date: {}\nThresholds: {} (Pred) {} (Align)\nMot\
ifs found: {}".format(self.filename(), self.date(), self.pred(),
                      self.ali(), len(self.motifs))
        return s

    def __repr__(self):

        return self.__str__()

    def __getitem__(self, index):
        """Return the motif of the given index."""

        return self._motifs[index]

    def __iter__(self):
        """Iterates over motifs in MotifFile."""

        return self._motifs.__iter__()

    def pred(self):
        """Return the prediction score (phylogenetic score) threshold used."""
        return self._pred_thre

    def ali(self):
        """Return the average alignment score threshold used in BigFoot."""
        return self._ali_thre

    def date(self):
        """Return the date the analysis was done."""
        return time.strftime("%a, %d %b %Y %H:%M:%S", self._date)

    def filename(self):
        """Return the name of parsed BigFoot's output file."""
        return self._filename

    def motifs(self):
        """Return a list of found motifs."""
        return self.motifs


class WeightedMotif(motifs.Motif):
    """
    Extension of Bio.motifs.Motif class, adding two attributes:
        - self.pred: average prediction (phylogenetic) score of the given motif
        - self.ali: average alignment score of the given motif
    """
    def __init__(self, alphabet, instances, phylo_score, align_score):
        motifs.Motif.__init__(self, alphabet, instances)
        self.pred = phylo_score
        self.ali = align_score


def load_meme(filename):
    """
    Return a parsed MEME output file using Biopython.
    """
    gapped = Gapped(ExtendedIUPACDNA(), '-')

    with open(filename, "r") as f:
        records = []
        records = motifs.parse(f, "MEME")

    records.sort(key=lambda x: x.evalue)  # Sort entries by evalue

    records = convert(records, gapped)
    return records


def convert(motifs_list, alphabet):
    """
    Returns a new list of motifs converting using given alphabet.
    """

    new_list = []
    for motif in motifs_list:
        tot_inst = []

        # Recreate instances using given alphabet
        for i in motif.instances:
            inst = meme.Instance(i.tostring(), alphabet)
            inst.motif_name = i.motif_name
            inst.sequence_name = i.sequence_name
            inst.start = int(i.start)
            inst.length = int(i.length)

            tot_inst.append(inst)
        tot_inst = motifs.Instances(tot_inst, alphabet)

        # Converting instances and motifs
        mot = meme.Motif(alphabet=alphabet, instances=tot_inst)
        mot.name = motif.name
        mot.evalue = motif.evalue

        new_list.append(mot)

    return new_list


def compare_motifs(bigfoot_motifs, meme_motifs, output=None, threshold=None,
                   evalue=None):
    """
    Compare motifs found in bigfoot and meme outputs, using an overlapping
    threshold index (float)
    """
    if threshold is None:
        threshold = 0.9

    if output is None:
        output = "BigFootMEMEcomp.txt"

    if evalue is None:
        evalue = 0.01

    i = 0  # printing index
    # Look at all motifs of bigfoot file
    for bf_mot in bigfoot_motifs.motifs():
        # Compare only first instance of each bf_mot
        inst = bf_mot.instances[0]
        start = inst.start
        end = start + inst.length - 1
        bf_range = (start, end)

        seq_name = inst.sequence_name

        # Compare the first instance of one motifs to all other motifs in MEME
        for m_mot in meme_motifs:
            if m_mot.evalue <= evalue:
                for m in m_mot.instances:
                    m_start = 0
                    m_end = 0
                    if m.sequence_name == seq_name:
                        # We found the instance from the same sequence \o/
                        m_start = m.start
                        m_end = m_start + m.length - 1
                        m_range = (m_start, m_end)

                        index, stat = overlap(bf_range, m_range)

                        if index and stat > threshold:
                            if i == 0:
                                print >> output, "BigFoot\tBF.length\tMEME\t\
MEME.length\tsequence\tratio"
                                i = 1
                            print >> output, "{}\t{}\t{}\t{}\t{}\t{}".format(
                                inst.motif_name, int(inst.length),
                                m.motif_name, int(m.length), seq_name, stat)
                        break


def overlap(r1, r2, need_stat=None):
    """
    Returns if the two ranges are overlapping. Notes, range should be\
    given in order (with start <= end). If overlapping stat is need,
    set need_stat to True
    (default = True)

    Examples:
    >>> overlap((2,3), (5,10))
    (False, 0.0)
    >>> overlap((2,3), (1,10))
    (True, 0.2)
    >>> overlap((5,15), (3,8))
    (True, 0.36363636363636365)
    >>> overlap((3,7), (5,9))
    (True, 0.6)
    """
    stat = 0.0
    if need_stat is None:
        need_stat = True

    index = (r2[0] <= r1[0] <= r2[1]) or (r1[0] <= r2[0] <= r1[1])

    if index:

        r1_len = r1[1] - r1[0] + 1
        r2_len = r2[1] - r2[0] + 1
        mini = min(r1_len, r2_len)
        maxi = max(r1_len, r2_len)

        # If range is included into the other
        if (r2[0] <= r1[0] <= r2[1]) and (r2[0] <= r1[1] <= r2[1]):
            over_r = r1_len
        elif (r1[0] <= r2[0] <= r1[1]) and (r1[0] <= r2[1] <= r1[1]):
            over_r = r2_len
        # If ranges are overlapping partially
        elif (r2[0] <= r1[0] <= r2[1]):
            over_r = r2[1] - r1[0] + 1
        elif (r1[0] <= r2[0] <= r1[1]):
            over_r = r1[1] - r2[0] + 1

        stat = float(over_r)/mini
    if need_stat:
        return index, stat
    else:
        return index


def _read_motif_seq(block):
    """
    From the block of lines used in MotifFile, return a Motif object
    """
    gapped = Gapped(ExtendedIUPACDNA(), '-')
    instances = []
    head = block[0][0]
    head = head.rstrip("\n").split(" ")
    motif_name = head[0]
    motif_length = head[-1]

    for l in block[1]:
        l = l.rstrip("\n").split("\t")
        instance = meme.Instance(l[-1], gapped)

        instance.motif_name = motif_name
        instance.sequence_name = l[0].translate(None, " ")
        instance.start = int(l[1].translate(None, " "))
        instance.length = int(motif_length)

        instances.append(instance)

    instances = motifs.Instances(instances, alphabet=gapped)

    motif = WeightedMotif(gapped, instances, float(head[-5]), float(head[-3]))
    motif.length = motif_length
    motif.name = motif_name

    return motif


def main():
    """Main program, containing the command-line parser"""

    # ## Command-line Parser ###
    parser = argparse.ArgumentParser(description="Command-line program to\
        compare motifs outputs of MEME and BigFoot.")

    parser.add_argument("bigf", help="BigFoot's output file")
    parser.add_argument("meme", help="MEME's output text file (see MEME's\
options -text)")
    parser.add_argument("-t", "--thre", help="threshold use for comparison ->\
retain only motif where you have ~n percent of overlap? \
(default: %(default)s)", type=float, default=0.9)
    parser.add_argument("-o", "--output", help="output file name",
                        type=argparse.FileType("w"),
                        default="BigFootMEMEcomp.txt")
    parser.add_argument("-e", "--evalue", help="MEME evalue threshold\
(default: %(default)s)", type=float, default=0.01)

    args = parser.parse_args()

    bigf = MotifFile(args.bigf)
    meme_file = load_meme(args.meme)

    print "Comparing motifs..."
    compare_motifs(bigf, meme_file, args.output, args.thre, args.evalue)
    print "Done."

if __name__ == "__main__":
    main()
