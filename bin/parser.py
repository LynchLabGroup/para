#!/usr/bin/env python
# -*- coding: utf-8 -*-
from weight import WeightSeq
from time import gmtime, strftime, sleep


class SeqParser(object):
	"""
	Object that takes in parameter BigFoot's alignement file and phylogenetic prediction file. It can parse file to extract motifs.
	"""

	def __init__(self,seqfile,predfile):
		"""
		seqfile - BigFoot's StatAlign ouput file
		predfile - BigFoot's '.pred' file of phylogenetic prediction
		"""

		self._seqfile = seqfile
		self._predfile = predfile
		self._parse = None #to stock the parsed sequences
		self._motifs = None

	def __str__(self):

		s = "Sequence File: {}\nPrediction File: {}".format(self._seqfile,self._predfile)

		return s

	def __repr__(self):
		return self.__str__()

	def parse(self):
		"""
		Returns a list of WeightSeq extracted from the sequence file
		"""

		if self._parse == None:

			seqs = [] #list of Weighted Sequences generated by parsing file

			with open(self._seqfile,"r") as f:
				for i,l in enumerate(f.readlines()):
					try:
						float(l) #try if line is numbers only
					except ValueError:
						seqs.append(WeightSeq(l))

			self._parse = seqs

			return seqs
		else:
			return "Sequence file was already parsed"

	def motifs(self,thre,size):
		"""
		Returns a dictionary of sequences motifs, using the prediction threshold thre and bigger than given size
		"""

		if self._parse == None:
			print "No previous parsing"
			print "Parsing file..."
			seqs = self.parse()
			self._parse = seqs
			print "Done"
		else:
			seqs = self._parse

		seqs[0].weight(self._predfile) #weight first sequence
		sleep(1)
		known = seqs[0].motifs(thre,size) #extract motifs with given threshold from first sequence

		mot = {} #motifs dictionary

		for i,k in enumerate(known):

			name = "motif"+str(i+1) #enumerate motifs

			mot[name] = {}

			mot[name]["start"] = k[1] #start position of motif
			mot[name]["stop"] = k[2] #end position of motif
			mot[name]["score"] = k[3] # average score
			mot[name]["size"]  = k[2] - k[1] + 1 #compute the size of the motif

			for s in seqs:
				mot[name][s.name()] = s[k[1]:k[2]] #extract motif from each sequence

		mot["threshold"] = thre
		mot["size"] = size
		self._motifs = mot

		return mot

	def write(self,output):
		"""
		Write the output file of all the found motifs. Compute the motifs search first.
		"""

		keys = self._motifs.keys()
		keys.sort()
		thre = self._motifs['threshold']
		size = self._motifs["size"]
		with open(output,"w") as o:

			#Print the precise time of the computation and print the whole results file
			print >> o, "Launched:{} GMT Threshold used: {} Size(over): {}\n".format(strftime("%a, %d %b %Y %H:%M:%S", gmtime()),thre,size)
			for k in keys:
				if k != "threshold" and k != "size":
					print >> o, "\n{} Start: {} Stop: {} AvgPhylogeneticScore: {} Size: {}\n".format(k,self._motifs[k]["start"],self._motifs[k]["stop"],self._motifs[k]["score"], self._motifs[k]["size"])

					sub = self._motifs[k].keys()
					sub.sort()
					seqs = []
					for s in sub:
						if s != "start" and s != "stop" and s != "score" and s != "size":
							print >> o, "{0:20} {1}".format(s,self._motifs[k][s].upper())

							


